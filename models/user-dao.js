const SQL = require('sql-template-strings');
const dbPromise = require("../database/database");
const moment = require("moment");
const debug = require("debug");

//debug namespace
const devUserDAO = debug('devLog:dao_users');

/** Creates a new user
* @param user, the user to insert into the database 
*/
async function createUser(user) {
  devUserDAO("createUser(user) : attempt to create new user with user object");
  const db = await dbPromise;
  const created_at = moment(new (Date)).format('YYYY-MM-DD HH:mm:ss');
  const result = await db.run(SQL`INSERT INTO app_users (username, email, password, name, created_at) VALUES (
    ${user.username},
    ${user.email},
    ${user.password},
    ${user.realName},
    ${created_at});`);
  // get the id generated by the db and assign it back to the user object
  user.id = result.lastID;
  return user
};

/** Gets the user with the given username from the database.
 * If there is no such user, undefined will be returned.
 * 
 * @param {string} username
 */
async function retrieveUserWithUserName(username) {
  devUserDAO(`retrieveUserWithUserName(username) : attempt retrieve user with ${username}`);
  const db = await dbPromise;
  const user = await db.get(SQL`SELECT * FROM app_users WHERE
      username = ${username};`);
  return user;
};

/** Checks with the provided authToken if a user in the
 * the db as a matching token.
 * If there is no such user, undefined will be returned.
 * 
 * @param {string} authToken
 */
async function retrieveUserWithAuthToken(authToken) {
  devUserDAO(`retrieveUserWithAuthToken(authToken): attempt to find user with authToken`)
  const db = await dbPromise;
  const user = await db.get(SQL`SELECT * FROM 
                  app_users 
                  WHERE 
                  authToken = ${authToken};`);
  if (user == undefined) {
    devUserDAO('No/Invalid authToken in client request')
  } else {
    devUserDAO('retrieved: ', user.username, " with auth token: ", user.authToken);
  }
  return user;
};

/** Gets the user with the given email from the database.
 * 
 * @param email a query string
 */
async function retrieveUserWithEmail(email) {
  devUserDAO(`retrieveUserWithEmail(email: ${email})`)
  const db = await dbPromise;
  const user = await db.get(SQL`
      SELECT * FROM app_users 
      WHERE
      email = ${email};`);
  return user;
};

/** Update existing user details in db using passed new user object keys/values.
 * @param {object} user
 */
async function updateUser(user) {
  devUserDAO(`updateUser(${user.username})`)
  if (!user || typeof user !== 'object' || Object.keys(user).length === 0) {
    devUserDAO(`Invalid user object: ${user}`);
    return false;
  }

  db = await dbPromise;

  devUserDAO(`updateUser(user): attempt to update user...`);
  devUserDAO(`User: ${user.username} (id: ${user.id} ) ...`);
  const updated_at = moment(new (Date)).format('YYYY-MM-DD HH:mm:ss');
  const setClause = Object.keys(user).map(key => `${key} = ?`).join(', ');
  const values = Object.values(user).concat(updated_at, user.id);
  devUserDAO(`setClause: ${setClause}`);
  devUserDAO(`values: ${values}`);
  const sql = `UPDATE app_users SET ${setClause}, updated_at = ? WHERE id = ?;`;
  devUserDAO(`sql: ${sql}`);
  try {
    await db.run(sql, values);
    devUserDAO(`User: ${user.username} (id: ${user.id} ) updated at: ${updated_at}`);
    return true;
  } catch (err) {
    devUserDAO(`Error updating user: ${err.message}`);
    return false;
  }
}

module.exports = {
  createUser,
  retrieveUserWithUserName,
  retrieveUserWithAuthToken,
  retrieveUserWithEmail,
  updateUser
};