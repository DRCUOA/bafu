const SQL = require('sql-template-strings');
const dbPromise = require("../database/database");
const moment = require("moment");
const debug = require("debug");

//debug namespace
const devUserDAO = debug('devLog:dao_users');

/** Creates a new user
* @param user, the user to insert into the database 
*/
async function createUser(user) {
  devUserDAO("createUser(user) : attempt to create new user with user object");
  const db = await dbPromise;
  const created_at = moment(new (Date)).format('YYYY-MM-DD HH:mm:ss');
  const result = await db.run(SQL`INSERT INTO app_users (username, email, password, name, created_at) VALUES (
    ${user.username},
    ${user.email},
    ${user.password},
    ${user.realName},
    ${created_at});`);
  // get the id generated by the db and assign it back to the user object
  user.id = result.lastID;
  return user
};

/** Gets the user with the given username from the database.
 * If there is no such user, undefined will be returned.
 * 
 * @param {string} username
 */
async function retrieveUserWithUserName(username) {
  devUserDAO(`retrieveUserWithUserName(username) : attempt retrieve user with ${username}`);
  const db = await dbPromise;
  const user = await db.get(SQL`SELECT * FROM app_users WHERE
      username = ${username};`);
  return user;
};

/** Checks with the provided authToken if a user in the
 * the db as a matching token.
 * If there is no such user, undefined will be returned.
 * 
 * @param {string} authToken
 */
async function retrieveUserWithAuthToken(authToken) {
  devUserDAO(`retrieveUserWithAuthToken(authToken): attempt to find user with authToken`)
  const db = await dbPromise;
  const user = await db.get(SQL`SELECT * FROM 
                  app_users 
                  WHERE 
                  authToken = ${authToken};`);
  if (user == undefined) {
    devUserDAO('No/Invalid authToken in client request')
  } else {
    devUserDAO('retrieved: ', user.username, " with auth token: ", user.authToken);
  }
  return user;
};


/** Gets the user with the given email from the database.
 * 
 * @param email a query string
 */
async function retrieveUserWithEmail(email) {
  devUserDAO('retrieveUserWithEmail(email)')
  const db = await dbPromise;
  const user = await db.get(SQL`
      SELECT * FROM app_users 
      WHERE
      email = ${email};`);
  return user;
};

/** Update existing user details in db using passed new user object keys/values.
 * @param {object} user
 */
async function updateUser(user) {
  if (!user || typeof user !== 'object' || Object.keys(user).length === 0) {
    devUserDAO(`Invalid user object: ${user}`);
    return false;
  }

  devUserDAO(`updateUser(user): attempt to update user...`);
  devUserDAO(`User: ${user.username} (id: ${user.id} ) ...`);
  db = await dbPromise;
  const updated_at = moment(new (Date)).format('YYYY-MM-DD HH:mm:ss');
  devUserDAO(`User: ${user.username} (id: ${user.id} ) updated at: ${updated_at}`);

  try {
    await db.run(SQL`
      UPDATE app_users
      SET authToken = ${user.authToken},
          updated_at = ${updated_at}
      WHERE id = ${user.id};
    `);
    return true;

  } catch (err) {
    devUserDAO(`Error updating user: ${err.message}`);
    return false;
  }
}

module.exports = {
  createUser,
  retrieveUserWithUserName,
  retrieveUserWithAuthToken,
  retrieveUserWithEmail,
  updateUser
};


/*LEARNING NOTE:

Dynamic generation of the SQL SET Clause using Object.keys/values:

Using Object.keys and Object.values methods to dynamically generate the SET clause has a few advantages:

It allows for more efficient and cleaner code. Instead of having to manually create each field and value pair, we can dynamically generate them using the Object.keys and Object.values methods. This can greatly reduce the amount of code that we need to write and maintain.

It makes our code more flexible. If we need to add or remove fields in the future, we can do so without having to change the SQL statement. The Object.keys and Object.values methods will automatically generate the correct SQL statement based on the fields that are present in the user object.

It helps to prevent errors. By dynamically generating the SET clause, we can ensure that we are only updating the fields that we want to update. This can help to prevent errors that can occur when manually creating the SET clause.

*/