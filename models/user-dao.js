const SQL = require('sql-template-strings');
const dbPromise = require("../database/database");
const moment = require("moment");
const debug = require("debug");

//debug namespace
const devUserDAO = debug('devLog:dao_users');

/** Creates a new user
* @param user, the user to insert into the database 
*/
async function createUser(user) {
  devUserDAO("createUser(user) : attempt to create new user with user object");
  const db = await dbPromise;
  const created_at = moment(new (Date)).format('YYYY-MM-DD HH:mm:ss');
  const result = await db.run(SQL`INSERT INTO app_users (username, email, password, name, created_at) VALUES (
    ${user.username},
    ${user.email},
    ${user.password},
    ${user.realName},
    ${created_at});`);
  // get the id generated by the db and assign it back to the user object
  user.id = result.lastID;
  return user
};

/** Gets the user with the given username from the database.
 * If there is no such user, undefined will be returned.
 * 
 * @param {string} username
 */
async function retrieveUserWithUserName(username) {
  devUserDAO(`retrieveUserWithUserName(username) : attempt retrieve user with ${username}`);
  const db = await dbPromise;
  const user = await db.get(SQL`SELECT * FROM app_users WHERE
      username = ${username};`);
  return user;
};

/** Checks with the provided authToken if a user in the
 * the db as a matching token.
 * If there is no such user, undefined will be returned.
 * 
 * @param {string} authToken
 */
async function retrieveUserWithAuthToken(authToken) {
  devUserDAO(`retrieveUserWithAuthToken(authToken): attempt to find user with authToken`)
  const db = await dbPromise;
  const user = await db.get(SQL`SELECT * FROM 
                  app_users 
                  WHERE 
                  authToken = ${authToken};`);
  if (user == undefined) {
    devUserDAO('No/Invalid authToken in client request')
  } else {
    devUserDAO('retrieved: ', user.username, " with auth token: ", user.authToken);
  }
  return user;
};


/** Gets the user with the given email from the database.
 * 
 * @param email a query string
 */
async function retrieveUserWithEmail(email) {
  devUserDAO(`retrieveUserWithEmail(email: ${email})`)
  const db = await dbPromise;
  const user = await db.get(SQL`
      SELECT * FROM app_users 
      WHERE
      email = ${email};`);
  devUserDAO(user.username)
  return user;
};

/** Update existing user details in db using passed new user object keys/values.
 * @param {object} user
 */
async function updateUser(user) {
  devUserDAO(`updateUser(${user.username})`)
  if (!user || typeof user !== 'object' || Object.keys(user).length === 0) {
    devUserDAO(`Invalid user object: ${user}`);
    return false;
  }

  db = await dbPromise;

  devUserDAO(`updateUser(user): attempt to update user...`);
  devUserDAO(`User: ${user.username} (id: ${user.id} ) ...`);
  const updated_at = moment(new (Date)).format('YYYY-MM-DD HH:mm:ss');
  const setClause = Object.keys(user).map(key => `${key} = ?`).join(', ');
  const values = Object.values(user).concat(updated_at, user.id);
  devUserDAO(`setClause: ${setClause}`);
  devUserDAO(`values: ${values}`);
  const sql = `UPDATE app_users SET ${setClause}, updated_at = ? WHERE id = ?;`;
  devUserDAO(`sql: ${sql}`);
  try {
    await db.run(sql, values);
    devUserDAO(`User: ${user.username} (id: ${user.id} ) updated at: ${updated_at}`);
    return true;
  } catch (err) {
    devUserDAO(`Error updating user: ${err.message}`);
    return false;
  }
}


//start of reset section
// Retrieve a user by email - already coverd above
// function retrieveUserWithEmail(email) {
//   return new Promise((resolve, reject) => {
//     const sql = `SELECT * FROM app_users WHERE email = ?`;
//     db.get(sql, [email], (err, row) => {
//       if (err) {
//         reject(err);
//       } else {
//         resolve(row);
//       }
//     });
//   });
// }

// Retrieve a user by id
function retrieveUserWithId(id) {
  return new Promise((resolve, reject) => {
    const sql = `SELECT * FROM app_users WHERE id = ?`;
    db.get(sql, [id], (err, row) => {
      if (err) {
        reject(err);
      } else {
        resolve(row);
      }
    });
  });
}

// Update a user's password
function updateUserPassword(email, password) {
  return new Promise((resolve, reject) => {
    const sql = `UPDATE app_users SET password = ? WHERE email = ?`;
    db.run(sql, [password, email], function (err) {
      if (err) {
        reject(err);
      } else {
        resolve(this.changes > 0);
      }
    });
  });
}

// Save a reset token for a user
function saveResetToken(email, token, expiration) {
  return new Promise((resolve, reject) => {
    const sql = `INSERT INTO reset_tokens (email, token, expires_at) VALUES (?, ?, ?)`;
    db.run(sql, [email, token, expiration], function (err) {
      if (err) {
        reject(err);
      } else {
        resolve(this.lastID);
      }
    });
  });
}

// Retrieve a reset token for a user
function getResetToken(email) {
  return new Promise((resolve, reject) => {
    const sql = `SELECT * FROM reset_tokens WHERE email = ?`;
    db.get(sql, [email], (err, row) => {
      if (err) {
        reject(err);
      } else {
        resolve(row);
      }
    });
  });
}

// Delete a reset token for a user
function deleteResetToken(email) {
  return new Promise((resolve, reject) => {
    const sql = `DELETE FROM reset_tokens WHERE email = ?`;
    db.run(sql, [email], function (err) {
      if (err) {
        reject(err);
      } else {
        resolve(this.changes > 0);
      }
    });
  });
}
//end of reset section

module.exports = {
  createUser,
  retrieveUserWithUserName,
  retrieveUserWithAuthToken,
  retrieveUserWithEmail,
  retrieveUserWithId,
  updateUserPassword,
  updateUser,
  deleteResetToken,
  saveResetToken,
  getResetToken,
};


/*LEARNING NOTE:

Dynamic generation of the SQL SET Clause using Object.keys/values:

Using Object.keys and Object.values methods to dynamically generate the SET clause has a few advantages:

It allows for more efficient and cleaner code. Instead of having to manually create each field and value pair, we can dynamically generate them using the Object.keys and Object.values methods. This can greatly reduce the amount of code that we need to write and maintain.

It makes our code more flexible. If we need to add or remove fields in the future, we can do so without having to change the SQL statement. The Object.keys and Object.values methods will automatically generate the correct SQL statement based on the fields that are present in the user object.

It helps to prevent errors. By dynamically generating the SET clause, we can ensure that we are only updating the fields that we want to update. This can help to prevent errors that can occur when manually creating the SET clause.

*/